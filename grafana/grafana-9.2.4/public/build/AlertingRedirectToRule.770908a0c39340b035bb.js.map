{"version":3,"file":"AlertingRedirectToRule.770908a0c39340b035bb.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/react-use-virtual-0c21d950b6/3/opt/drone/yarncache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useLocation.js","webpack://grafana/./public/app/features/alerting/unified/RedirectToRuleViewer.tsx","webpack://grafana/./public/app/features/alerting/unified/components/rule-viewer/RuleViewerLayout.tsx","webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRule.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts"],"sourcesContent":["import { useEffect, useState } from 'react';\nimport { isBrowser, off, on } from './misc/util';\nvar patchHistoryMethod = function (method) {\n    var history = window.history;\n    var original = history[method];\n    history[method] = function (state) {\n        var result = original.apply(this, arguments);\n        var event = new Event(method.toLowerCase());\n        event.state = state;\n        window.dispatchEvent(event);\n        return result;\n    };\n};\nif (isBrowser) {\n    patchHistoryMethod('pushState');\n    patchHistoryMethod('replaceState');\n}\nvar useLocationServer = function () { return ({\n    trigger: 'load',\n    length: 1,\n}); };\nvar buildState = function (trigger) {\n    var _a = window.history, state = _a.state, length = _a.length;\n    var _b = window.location, hash = _b.hash, host = _b.host, hostname = _b.hostname, href = _b.href, origin = _b.origin, pathname = _b.pathname, port = _b.port, protocol = _b.protocol, search = _b.search;\n    return {\n        trigger: trigger,\n        state: state,\n        length: length,\n        hash: hash,\n        host: host,\n        hostname: hostname,\n        href: href,\n        origin: origin,\n        pathname: pathname,\n        port: port,\n        protocol: protocol,\n        search: search,\n    };\n};\nvar useLocationBrowser = function () {\n    var _a = useState(buildState('load')), state = _a[0], setState = _a[1];\n    useEffect(function () {\n        var onPopstate = function () { return setState(buildState('popstate')); };\n        var onPushstate = function () { return setState(buildState('pushstate')); };\n        var onReplacestate = function () { return setState(buildState('replacestate')); };\n        on(window, 'popstate', onPopstate);\n        on(window, 'pushstate', onPushstate);\n        on(window, 'replacestate', onReplacestate);\n        return function () {\n            off(window, 'popstate', onPopstate);\n            off(window, 'pushstate', onPushstate);\n            off(window, 'replacestate', onReplacestate);\n        };\n    }, []);\n    return state;\n};\nvar hasEventConstructor = typeof Event === 'function';\nexport default isBrowser && hasEventConstructor ? useLocationBrowser : useLocationServer;\n","import { css } from '@emotion/css';\nimport React from 'react';\nimport { Redirect } from 'react-router-dom';\nimport { useLocation } from 'react-use';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { Alert, Card, Icon, LoadingPlaceholder, useStyles2, withErrorBoundary } from '@grafana/ui';\n\nimport { AlertLabels } from './components/AlertLabels';\nimport { RuleViewerLayout } from './components/rule-viewer/RuleViewerLayout';\nimport { useCombinedRulesMatching } from './hooks/useCombinedRule';\nimport { getRulesSourceByName } from './utils/datasource';\nimport { createViewLink } from './utils/misc';\n\nconst pageTitle = 'Alerting / Find rule';\n\nfunction useRuleFindParams() {\n  // DO NOT USE REACT-ROUTER HOOKS FOR THIS CODE\n  // React-router's useLocation/useParams/props.match are broken and don't preserve original param values when parsing location\n  // so, they cannot be used to parse name and sourceName path params\n  // React-router messes the pathname up resulting in a string that is neither encoded nor decoded\n  // Relevant issue: https://github.com/remix-run/history/issues/505#issuecomment-453175833\n  // It was probably fixed in React-Router v6\n  const location = useLocation();\n  const segments = location.pathname?.split('/') ?? []; // [\"\", \"alerting\", \"{sourceName}\", \"{name}]\n\n  const name = decodeURIComponent(segments[3]);\n  const sourceName = decodeURIComponent(segments[2]);\n\n  return { name, sourceName };\n}\n\nexport function RedirectToRuleViewer(): JSX.Element | null {\n  const styles = useStyles2(getStyles);\n\n  const { name, sourceName } = useRuleFindParams();\n  const { error, loading, result: rules, dispatched } = useCombinedRulesMatching(name, sourceName);\n\n  if (error) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title={`Failed to load rules from ${sourceName}`}>\n          <details className={styles.errorMessage}>\n            {error.message}\n            <br />\n            {!!error?.stack && error.stack}\n          </details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (loading || !dispatched || !Array.isArray(rules)) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <LoadingPlaceholder text=\"Loading rule...\" />\n      </RuleViewerLayout>\n    );\n  }\n\n  if (!name || !sourceName) {\n    return <Redirect to=\"/notfound\" />;\n  }\n\n  const rulesSource = getRulesSourceByName(sourceName);\n\n  if (!rulesSource) {\n    return (\n      <RuleViewerLayout title={pageTitle}>\n        <Alert title=\"Could not view rule\">\n          <details className={styles.errorMessage}>{`Could not find data source with name: ${sourceName}.`}</details>\n        </Alert>\n      </RuleViewerLayout>\n    );\n  }\n\n  if (rules.length === 1) {\n    const [rule] = rules;\n    return <Redirect to={createViewLink(rulesSource, rule, '/alerting/list')} />;\n  }\n\n  return (\n    <RuleViewerLayout title={pageTitle}>\n      <div>\n        Several rules in <span className={styles.param}>{sourceName}</span> matched the name{' '}\n        <span className={styles.param}>{name}</span>, please select the rule you want to view.\n      </div>\n      <div className={styles.rules}>\n        {rules.map((rule, index) => {\n          return (\n            <Card key={`${rule.name}-${index}`} href={createViewLink(rulesSource, rule, '/alerting/list')}>\n              <Card.Heading>{rule.name}</Card.Heading>\n              <Card.Meta separator={''}>\n                <Icon name=\"folder\" />\n                <span className={styles.namespace}>{`${rule.namespace.name} / ${rule.group.name}`}</span>\n              </Card.Meta>\n              <Card.Tags>\n                <AlertLabels labels={rule.labels} />\n              </Card.Tags>\n            </Card>\n          );\n        })}\n      </div>\n    </RuleViewerLayout>\n  );\n}\n\nfunction getStyles(theme: GrafanaTheme2) {\n  return {\n    param: css`\n      font-style: italic;\n      color: ${theme.colors.text.secondary};\n    `,\n    rules: css`\n      margin-top: ${theme.spacing(2)};\n    `,\n    namespace: css`\n      margin-left: ${theme.spacing(1)};\n    `,\n    errorMessage: css`\n      white-space: pre-wrap;\n    `,\n  };\n}\n\nexport default withErrorBoundary(RedirectToRuleViewer, { style: 'page' });\n","import { css } from '@emotion/css';\nimport React from 'react';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { locationService } from '@grafana/runtime';\nimport { PageToolbar, useStyles2 } from '@grafana/ui';\nimport { Page } from 'app/core/components/Page/Page';\n\ntype Props = {\n  children: React.ReactNode | React.ReactNode[];\n  title: string;\n  wrapInContent?: boolean;\n};\n\nexport function RuleViewerLayout(props: Props): JSX.Element | null {\n  const { wrapInContent = true, children, title } = props;\n  const styles = useStyles2(getPageStyles);\n\n  return (\n    <Page>\n      <PageToolbar title={title} pageIcon=\"bell\" onGoBack={() => locationService.push('/alerting/list')} />\n      <div className={styles.content}>{wrapInContent ? <RuleViewerLayoutContent {...props} /> : children}</div>\n    </Page>\n  );\n}\n\ntype ContentProps = {\n  children: React.ReactNode | React.ReactNode[];\n  padding?: number;\n};\n\nexport function RuleViewerLayoutContent({ children, padding = 2 }: ContentProps): JSX.Element | null {\n  const styles = useStyles2(getContentStyles(padding));\n  return <div className={styles.wrapper}>{children}</div>;\n}\n\nconst getPageStyles = (theme: GrafanaTheme2) => {\n  return {\n    content: css`\n      margin: ${theme.spacing(0, 2, 2)};\n      max-width: ${theme.breakpoints.values.xxl}px;\n    `,\n  };\n};\n\nconst getContentStyles = (padding: number) => (theme: GrafanaTheme2) => {\n  return {\n    wrapper: css`\n      background: ${theme.colors.background.primary};\n      border: 1px solid ${theme.colors.border.weak};\n      border-radius: ${theme.shape.borderRadius()};\n      padding: ${theme.spacing(padding)};\n    `,\n  };\n};\n","import { useMemo } from 'react';\nimport { useAsync } from 'react-use';\n\nimport { useDispatch } from 'app/types';\nimport { CombinedRule, RuleIdentifier, RuleNamespace } from 'app/types/unified-alerting';\nimport { RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport { fetchPromAndRulerRulesAction } from '../state/actions';\nimport { AsyncRequestMapSlice, AsyncRequestState, initialAsyncRequestState } from '../utils/redux';\nimport * as ruleId from '../utils/rule-id';\nimport { isRulerNotSupportedResponse } from '../utils/rules';\n\nimport { useCombinedRuleNamespaces } from './useCombinedRuleNamespaces';\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\nexport function useCombinedRule(\n  identifier: RuleIdentifier | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rule = useMemo(() => {\n    if (!identifier || !ruleSourceName || combinedRules.length === 0) {\n      return;\n    }\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          const id = ruleId.fromCombinedRule(ruleSourceName, rule);\n\n          if (ruleId.equal(id, identifier)) {\n            return rule;\n          }\n        }\n      }\n    }\n\n    return;\n  }, [identifier, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rule,\n  };\n}\n\nexport function useCombinedRulesMatching(\n  ruleName: string | undefined,\n  ruleSourceName: string | undefined\n): AsyncRequestState<CombinedRule[]> {\n  const requestState = useCombinedRulesLoader(ruleSourceName);\n  const combinedRules = useCombinedRuleNamespaces(ruleSourceName);\n\n  const rules = useMemo(() => {\n    if (!ruleName || !ruleSourceName || combinedRules.length === 0) {\n      return [];\n    }\n\n    const rules: CombinedRule[] = [];\n\n    for (const namespace of combinedRules) {\n      for (const group of namespace.groups) {\n        for (const rule of group.rules) {\n          if (rule.name === ruleName) {\n            rules.push(rule);\n          }\n        }\n      }\n    }\n\n    return rules;\n  }, [ruleName, ruleSourceName, combinedRules]);\n\n  return {\n    ...requestState,\n    result: rules,\n  };\n}\n\nfunction useCombinedRulesLoader(rulesSourceName: string | undefined): AsyncRequestState<void> {\n  const dispatch = useDispatch();\n  const promRuleRequests = useUnifiedAlertingSelector((state) => state.promRules);\n  const promRuleRequest = getRequestState(rulesSourceName, promRuleRequests);\n  const rulerRuleRequests = useUnifiedAlertingSelector((state) => state.rulerRules);\n  const rulerRuleRequest = getRequestState(rulesSourceName, rulerRuleRequests);\n\n  const { loading } = useAsync(async () => {\n    if (!rulesSourceName) {\n      return;\n    }\n\n    await dispatch(fetchPromAndRulerRulesAction({ rulesSourceName }));\n  }, [dispatch, rulesSourceName]);\n\n  return {\n    loading,\n    error: promRuleRequest.error ?? isRulerNotSupportedResponse(rulerRuleRequest) ? undefined : rulerRuleRequest.error,\n    dispatched: promRuleRequest.dispatched && rulerRuleRequest.dispatched,\n  };\n}\n\nfunction getRequestState(\n  ruleSourceName: string | undefined,\n  slice: AsyncRequestMapSlice<RulerRulesConfigDTO | RuleNamespace[] | null>\n): AsyncRequestState<RulerRulesConfigDTO | RuleNamespace[] | null> {\n  if (!ruleSourceName) {\n    return initialAsyncRequestState;\n  }\n\n  const state = slice[ruleSourceName];\n\n  if (!state) {\n    return initialAsyncRequestState;\n  }\n\n  return state;\n}\n","import { isEqual } from 'lodash';\nimport { useMemo, useRef } from 'react';\n\nimport {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\n// merge all groups in case of grafana managed, essentially treating namespaces (folders) as groups\nexport function flattenGrafanaManagedRules(namespaces: CombinedRuleNamespace[]) {\n  return namespaces.map((namespace) => {\n    const newNamespace: CombinedRuleNamespace = {\n      ...namespace,\n      groups: [],\n    };\n\n    // add default group with ungrouped rules\n    newNamespace.groups.push({\n      name: 'default',\n      rules: sortRulesByName(namespace.groups.flatMap((group) => group.rules)),\n    });\n\n    return newNamespace;\n  });\n}\n\nexport function sortRulesByName(rules: CombinedRule[]) {\n  return rules.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[] = []): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      interval: group.interval,\n      source_tenants: group.source_tenants,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  const existingGroupsByName = new Map<string, CombinedRuleGroup>();\n  namespace.groups.forEach((group) => existingGroupsByName.set(group.name, group));\n\n  groups.forEach((group) => {\n    let combinedGroup = existingGroupsByName.get(group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n      existingGroupsByName.set(group.name, combinedGroup);\n    }\n\n    const combinedRulesByName = new Map<string, CombinedRule[]>();\n    combinedGroup!.rules.forEach((r) => {\n      // Prometheus rules do not have to be unique by name\n      const existingRule = combinedRulesByName.get(r.name);\n      existingRule ? existingRule.push(r) : combinedRulesByName.set(r.name, [r]);\n    });\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedRulesByName, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  existingCombinedRulesMap: Map<string, CombinedRule[]>,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  // Using Map of name-based rules is important performance optimization for the code below\n  // Otherwise we would perform find method multiple times on (possibly) thousands of rules\n\n  const nameMatchingRules = existingCombinedRulesMap.get(rule.name);\n  if (!nameMatchingRules) {\n    return undefined;\n  }\n\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return nameMatchingRules[0];\n  }\n\n  // try finding a rule that matches name, labels, annotations and query\n  const strictlyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, true)\n  );\n  if (strictlyMatchingRule) {\n    return strictlyMatchingRule;\n  }\n\n  // if that fails, try finding a rule that only matches name, labels and annotations.\n  // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n  const looselyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, false)\n  );\n  if (looselyMatchingRule) {\n    return looselyMatchingRule;\n  }\n\n  return undefined;\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return isEqual(\n      [checkQuery ? hashQuery(combinedRule.query) : '', combinedRule.labels, combinedRule.annotations],\n      [checkQuery ? hashQuery(rule.query) : '', rule.labels || {}, isAlertingRule(rule) ? rule.annotations || {} : {}]\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.slice(1, -1);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n"],"names":["patchHistoryMethod","method","history","window","original","state","result","apply","this","arguments","event","Event","toLowerCase","dispatchEvent","buildState","trigger","_a","length","_b","location","hash","host","hostname","href","origin","pathname","port","protocol","search","hasEventConstructor","useState","setState","useEffect","onPopstate","onPushstate","onReplacestate","on","pageTitle","RedirectToRuleViewer","styles","useStyles2","getStyles","name","sourceName","segments","useLocation","split","decodeURIComponent","useRuleFindParams","error","loading","rules","dispatched","useCombinedRulesMatching","RuleViewerLayout","title","Alert","className","errorMessage","message","stack","Array","isArray","LoadingPlaceholder","text","to","rulesSource","getRulesSourceByName","rule","createViewLink","param","map","index","Card","separator","Icon","namespace","group","AlertLabels","labels","theme","css","colors","secondary","spacing","withErrorBoundary","style","props","wrapInContent","children","getPageStyles","pageIcon","onGoBack","locationService","content","RuleViewerLayoutContent","padding","getContentStyles","wrapper","breakpoints","values","xxl","background","primary","border","weak","shape","borderRadius","useCombinedRule","identifier","ruleSourceName","requestState","useCombinedRulesLoader","combinedRules","useCombinedRuleNamespaces","useMemo","groups","id","ruleId","ruleName","push","rulesSourceName","dispatch","useDispatch","promRuleRequests","useUnifiedAlertingSelector","promRules","promRuleRequest","getRequestState","rulerRuleRequests","rulerRules","rulerRuleRequest","useAsync","async","fetchPromAndRulerRulesAction","isRulerNotSupportedResponse","undefined","slice","initialAsyncRequestState","promRulesResponses","rulerRulesResponses","cache","useRef","rulesSources","Error","getAllRulesSources","isCloudRulesSource","cached","current","namespaces","Object","entries","forEach","namespaceName","combinedGroup","interval","source_tenants","rulerRuleToCombinedRule","addRulerGroupsToCombinedNamespace","existingGroupsByName","Map","set","get","combinedRulesByName","r","existingRule","existingCombinedRulesMap","nameMatchingRules","isGrafanaRulesSource","strictlyMatchingRule","find","combinedRule","promRule","isCombinedRuleEqualToPromRule","looselyMatchingRule","getExistingRuleInGroup","query","annotations","isAlertingRule","promRuleToCombinedRule","addPromGroupsToCombinedNamespace","flat","flattenGrafanaManagedRules","newNamespace","flatMap","sort","a","b","localeCompare","isAlertingRulerRule","alert","expr","rulerRule","isRecordingRulerRule","record","grafana_alert","checkQuery","isEqual","hashQuery","replace","join"],"sourceRoot":""}