{"version":3,"file":"FolderAlerting.17ebc86642c8b65e2009.js","mappings":"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","sources":["webpack://grafana/./public/app/features/alerting/unified/hooks/useCombinedRuleNamespaces.ts","webpack://grafana/./public/app/features/alerting/unified/hooks/useURLSearchParams.ts","webpack://grafana/./public/app/features/alerting/unified/AlertsFolderView.tsx","webpack://grafana/./public/app/features/folders/FolderAlerting.tsx"],"sourcesContent":["import { isEqual } from 'lodash';\nimport { useMemo, useRef } from 'react';\n\nimport {\n  CombinedRule,\n  CombinedRuleGroup,\n  CombinedRuleNamespace,\n  Rule,\n  RuleGroup,\n  RuleNamespace,\n  RulesSource,\n} from 'app/types/unified-alerting';\nimport { RulerRuleDTO, RulerRuleGroupDTO, RulerRulesConfigDTO } from 'app/types/unified-alerting-dto';\n\nimport {\n  getAllRulesSources,\n  getRulesSourceByName,\n  isCloudRulesSource,\n  isGrafanaRulesSource,\n} from '../utils/datasource';\nimport { isAlertingRule, isAlertingRulerRule, isRecordingRulerRule } from '../utils/rules';\n\nimport { useUnifiedAlertingSelector } from './useUnifiedAlertingSelector';\n\ninterface CacheValue {\n  promRules?: RuleNamespace[];\n  rulerRules?: RulerRulesConfigDTO | null;\n  result: CombinedRuleNamespace[];\n}\n\n// this little monster combines prometheus rules and ruler rules to produce a unified data structure\n// can limit to a single rules source\nexport function useCombinedRuleNamespaces(rulesSourceName?: string): CombinedRuleNamespace[] {\n  const promRulesResponses = useUnifiedAlertingSelector((state) => state.promRules);\n  const rulerRulesResponses = useUnifiedAlertingSelector((state) => state.rulerRules);\n\n  // cache results per rules source, so we only recalculate those for which results have actually changed\n  const cache = useRef<Record<string, CacheValue>>({});\n\n  const rulesSources = useMemo((): RulesSource[] => {\n    if (rulesSourceName) {\n      const rulesSource = getRulesSourceByName(rulesSourceName);\n      if (!rulesSource) {\n        throw new Error(`Unknown rules source: ${rulesSourceName}`);\n      }\n      return [rulesSource];\n    }\n    return getAllRulesSources();\n  }, [rulesSourceName]);\n\n  return useMemo(\n    () =>\n      rulesSources\n        .map((rulesSource): CombinedRuleNamespace[] => {\n          const rulesSourceName = isCloudRulesSource(rulesSource) ? rulesSource.name : rulesSource;\n          const promRules = promRulesResponses[rulesSourceName]?.result;\n          const rulerRules = rulerRulesResponses[rulesSourceName]?.result;\n\n          const cached = cache.current[rulesSourceName];\n          if (cached && cached.promRules === promRules && cached.rulerRules === rulerRules) {\n            return cached.result;\n          }\n          const namespaces: Record<string, CombinedRuleNamespace> = {};\n\n          // first get all the ruler rules in\n          Object.entries(rulerRules || {}).forEach(([namespaceName, groups]) => {\n            const namespace: CombinedRuleNamespace = {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            };\n            namespaces[namespaceName] = namespace;\n            addRulerGroupsToCombinedNamespace(namespace, groups);\n          });\n\n          // then correlate with prometheus rules\n          promRules?.forEach(({ name: namespaceName, groups }) => {\n            const ns = (namespaces[namespaceName] = namespaces[namespaceName] || {\n              rulesSource,\n              name: namespaceName,\n              groups: [],\n            });\n\n            addPromGroupsToCombinedNamespace(ns, groups);\n          });\n\n          const result = Object.values(namespaces);\n\n          cache.current[rulesSourceName] = { promRules, rulerRules, result };\n          return result;\n        })\n        .flat(),\n    [promRulesResponses, rulerRulesResponses, rulesSources]\n  );\n}\n\n// merge all groups in case of grafana managed, essentially treating namespaces (folders) as groups\nexport function flattenGrafanaManagedRules(namespaces: CombinedRuleNamespace[]) {\n  return namespaces.map((namespace) => {\n    const newNamespace: CombinedRuleNamespace = {\n      ...namespace,\n      groups: [],\n    };\n\n    // add default group with ungrouped rules\n    newNamespace.groups.push({\n      name: 'default',\n      rules: sortRulesByName(namespace.groups.flatMap((group) => group.rules)),\n    });\n\n    return newNamespace;\n  });\n}\n\nexport function sortRulesByName(rules: CombinedRule[]) {\n  return rules.sort((a, b) => a.name.localeCompare(b.name));\n}\n\nfunction addRulerGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RulerRuleGroupDTO[] = []): void {\n  namespace.groups = groups.map((group) => {\n    const combinedGroup: CombinedRuleGroup = {\n      name: group.name,\n      interval: group.interval,\n      source_tenants: group.source_tenants,\n      rules: [],\n    };\n    combinedGroup.rules = group.rules.map((rule) => rulerRuleToCombinedRule(rule, namespace, combinedGroup));\n    return combinedGroup;\n  });\n}\n\nfunction addPromGroupsToCombinedNamespace(namespace: CombinedRuleNamespace, groups: RuleGroup[]): void {\n  const existingGroupsByName = new Map<string, CombinedRuleGroup>();\n  namespace.groups.forEach((group) => existingGroupsByName.set(group.name, group));\n\n  groups.forEach((group) => {\n    let combinedGroup = existingGroupsByName.get(group.name);\n    if (!combinedGroup) {\n      combinedGroup = {\n        name: group.name,\n        rules: [],\n      };\n      namespace.groups.push(combinedGroup);\n      existingGroupsByName.set(group.name, combinedGroup);\n    }\n\n    const combinedRulesByName = new Map<string, CombinedRule[]>();\n    combinedGroup!.rules.forEach((r) => {\n      // Prometheus rules do not have to be unique by name\n      const existingRule = combinedRulesByName.get(r.name);\n      existingRule ? existingRule.push(r) : combinedRulesByName.set(r.name, [r]);\n    });\n\n    (group.rules ?? []).forEach((rule) => {\n      const existingRule = getExistingRuleInGroup(rule, combinedRulesByName, namespace.rulesSource);\n      if (existingRule) {\n        existingRule.promRule = rule;\n      } else {\n        combinedGroup!.rules.push(promRuleToCombinedRule(rule, namespace, combinedGroup!));\n      }\n    });\n  });\n}\n\nfunction promRuleToCombinedRule(rule: Rule, namespace: CombinedRuleNamespace, group: CombinedRuleGroup): CombinedRule {\n  return {\n    name: rule.name,\n    query: rule.query,\n    labels: rule.labels || {},\n    annotations: isAlertingRule(rule) ? rule.annotations || {} : {},\n    promRule: rule,\n    namespace: namespace,\n    group,\n  };\n}\n\nfunction rulerRuleToCombinedRule(\n  rule: RulerRuleDTO,\n  namespace: CombinedRuleNamespace,\n  group: CombinedRuleGroup\n): CombinedRule {\n  return isAlertingRulerRule(rule)\n    ? {\n        name: rule.alert,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : isRecordingRulerRule(rule)\n    ? {\n        name: rule.record,\n        query: rule.expr,\n        labels: rule.labels || {},\n        annotations: {},\n        rulerRule: rule,\n        namespace,\n        group,\n      }\n    : {\n        name: rule.grafana_alert.title,\n        query: '',\n        labels: rule.labels || {},\n        annotations: rule.annotations || {},\n        rulerRule: rule,\n        namespace,\n        group,\n      };\n}\n\n// find existing rule in group that matches the given prom rule\nfunction getExistingRuleInGroup(\n  rule: Rule,\n  existingCombinedRulesMap: Map<string, CombinedRule[]>,\n  rulesSource: RulesSource\n): CombinedRule | undefined {\n  // Using Map of name-based rules is important performance optimization for the code below\n  // Otherwise we would perform find method multiple times on (possibly) thousands of rules\n\n  const nameMatchingRules = existingCombinedRulesMap.get(rule.name);\n  if (!nameMatchingRules) {\n    return undefined;\n  }\n\n  if (isGrafanaRulesSource(rulesSource)) {\n    // assume grafana groups have only the one rule. check name anyway because paranoid\n    return nameMatchingRules[0];\n  }\n\n  // try finding a rule that matches name, labels, annotations and query\n  const strictlyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, true)\n  );\n  if (strictlyMatchingRule) {\n    return strictlyMatchingRule;\n  }\n\n  // if that fails, try finding a rule that only matches name, labels and annotations.\n  // loki & prom can sometimes modify the query so it doesnt match, eg `2 > 1` becomes `1`\n  const looselyMatchingRule = nameMatchingRules.find(\n    (combinedRule) => !combinedRule.promRule && isCombinedRuleEqualToPromRule(combinedRule, rule, false)\n  );\n  if (looselyMatchingRule) {\n    return looselyMatchingRule;\n  }\n\n  return undefined;\n}\n\nfunction isCombinedRuleEqualToPromRule(combinedRule: CombinedRule, rule: Rule, checkQuery = true): boolean {\n  if (combinedRule.name === rule.name) {\n    return isEqual(\n      [checkQuery ? hashQuery(combinedRule.query) : '', combinedRule.labels, combinedRule.annotations],\n      [checkQuery ? hashQuery(rule.query) : '', rule.labels || {}, isAlertingRule(rule) ? rule.annotations || {} : {}]\n    );\n  }\n  return false;\n}\n\n// there can be slight differences in how prom & ruler render a query, this will hash them accounting for the differences\nfunction hashQuery(query: string) {\n  // one of them might be wrapped in parens\n  if (query.length > 1 && query[0] === '(' && query[query.length - 1] === ')') {\n    query = query.slice(1, -1);\n  }\n  // whitespace could be added or removed\n  query = query.replace(/\\s|\\n/g, '');\n  // labels matchers can be reordered, so sort the enitre string, esentially comparing just the character counts\n  return query.split('').sort().join('');\n}\n","import { useCallback, useMemo } from 'react';\nimport { useLocation } from 'react-router-dom';\n\nimport { locationService } from '@grafana/runtime';\n\nexport function useURLSearchParams(): [\n  URLSearchParams,\n  (searchValues: Record<string, string | string[] | undefined>, replace?: boolean) => void\n] {\n  const { search } = useLocation();\n  const queryParams = useMemo(() => new URLSearchParams(search), [search]);\n\n  const update = useCallback((searchValues: Record<string, string | string[] | undefined>, replace?: boolean) => {\n    locationService.partial(searchValues, replace);\n  }, []);\n\n  return [queryParams, update];\n}\n","import { css } from '@emotion/css';\nimport { isEqual, orderBy, uniqWith } from 'lodash';\nimport React, { useEffect, useState } from 'react';\nimport { useDebounce } from 'react-use';\n\nimport { GrafanaTheme2, SelectableValue } from '@grafana/data';\nimport { Stack } from '@grafana/experimental';\nimport { Card, FilterInput, Icon, Pagination, Select, TagList, useStyles2 } from '@grafana/ui';\nimport { DEFAULT_PER_PAGE_PAGINATION } from 'app/core/constants';\nimport { getQueryParamValue } from 'app/core/utils/query';\nimport { FolderState, useDispatch } from 'app/types';\nimport { CombinedRule } from 'app/types/unified-alerting';\n\nimport { useCombinedRuleNamespaces } from './hooks/useCombinedRuleNamespaces';\nimport { usePagination } from './hooks/usePagination';\nimport { useURLSearchParams } from './hooks/useURLSearchParams';\nimport { fetchPromRulesAction, fetchRulerRulesAction } from './state/actions';\nimport { labelsMatchMatchers, matchersToString, parseMatcher, parseMatchers } from './utils/alertmanager';\nimport { GRAFANA_RULES_SOURCE_NAME } from './utils/datasource';\nimport { createViewLink } from './utils/misc';\n\ninterface Props {\n  folder: FolderState;\n}\n\nenum SortOrder {\n  Ascending = 'alpha-asc',\n  Descending = 'alpha-desc',\n}\n\nconst sortOptions: Array<SelectableValue<SortOrder>> = [\n  { label: 'Alphabetically [A-Z]', value: SortOrder.Ascending },\n  { label: 'Alphabetically [Z-A]', value: SortOrder.Descending },\n];\n\nexport const AlertsFolderView = ({ folder }: Props) => {\n  const styles = useStyles2(getStyles);\n  const dispatch = useDispatch();\n\n  const onTagClick = (tagName: string) => {\n    const matchers = parseMatchers(labelFilter);\n    const tagMatcherField = parseMatcher(tagName);\n    const uniqueMatchers = uniqWith([...matchers, tagMatcherField], isEqual);\n    const matchersString = matchersToString(uniqueMatchers);\n    setLabelFilter(matchersString);\n  };\n\n  useEffect(() => {\n    dispatch(fetchPromRulesAction({ rulesSourceName: GRAFANA_RULES_SOURCE_NAME }));\n    dispatch(fetchRulerRulesAction({ rulesSourceName: GRAFANA_RULES_SOURCE_NAME }));\n  }, [dispatch]);\n\n  const combinedNamespaces = useCombinedRuleNamespaces(GRAFANA_RULES_SOURCE_NAME);\n  const { nameFilter, labelFilter, sortOrder, setNameFilter, setLabelFilter, setSortOrder } =\n    useAlertsFolderViewParams();\n\n  const matchingNamespace = combinedNamespaces.find((namespace) => namespace.name === folder.title);\n  const alertRules = matchingNamespace?.groups.flatMap((group) => group.rules) ?? [];\n\n  const filteredRules = filterAndSortRules(alertRules, nameFilter, labelFilter, sortOrder ?? SortOrder.Ascending);\n\n  const hasNoResults = alertRules.length === 0 || filteredRules.length === 0;\n  const { page, numberOfPages, onPageChange, pageItems } = usePagination(filteredRules, 1, DEFAULT_PER_PAGE_PAGINATION);\n\n  return (\n    <div className={styles.container}>\n      <Stack direction=\"column\" gap={3}>\n        <FilterInput\n          value={nameFilter}\n          onChange={setNameFilter}\n          placeholder=\"Search alert rules by name\"\n          data-testid=\"name-filter\"\n        />\n        <Stack direction=\"row\">\n          <Select<SortOrder>\n            value={sortOrder}\n            onChange={({ value }) => value && setSortOrder(value)}\n            options={sortOptions}\n            width={25}\n            aria-label=\"Sort\"\n            placeholder={`Sort (Default A-Z)`}\n            prefix={<Icon name={sortOrder === SortOrder.Ascending ? 'sort-amount-up' : 'sort-amount-down'} />}\n          />\n          <FilterInput\n            value={labelFilter}\n            onChange={setLabelFilter}\n            placeholder=\"Search alerts by labels\"\n            className={styles.filterLabelsInput}\n            data-testid=\"label-filter\"\n          />\n        </Stack>\n\n        <Stack gap={1}>\n          {pageItems.map((currentRule) => (\n            <Card\n              key={currentRule.name}\n              href={createViewLink('grafana', currentRule, '')}\n              className={styles.card}\n              data-testid=\"alert-card-row\"\n            >\n              <Card.Heading>{currentRule.name}</Card.Heading>\n              <Card.Tags>\n                <TagList\n                  onClick={onTagClick}\n                  tags={Object.entries(currentRule.labels).map(([label, value]) => `${label}=${value}`)}\n                />\n              </Card.Tags>\n              <Card.Meta>\n                <div>\n                  <Icon name=\"folder\" /> {folder.title}\n                </div>\n              </Card.Meta>\n            </Card>\n          ))}\n        </Stack>\n        {hasNoResults && <div className={styles.noResults}>No alert rules found</div>}\n        <div className={styles.pagination}>\n          <Pagination\n            currentPage={page}\n            numberOfPages={numberOfPages}\n            onNavigate={onPageChange}\n            hideWhenSinglePage={true}\n          />\n        </div>\n      </Stack>\n    </div>\n  );\n};\n\nenum AlertFolderViewParams {\n  nameFilter = 'nameFilter',\n  labelFilter = 'labelFilter',\n  sortOrder = 'sort',\n}\n\nfunction useAlertsFolderViewParams() {\n  const [searchParams, setSearchParams] = useURLSearchParams();\n\n  const [nameFilter, setNameFilter] = useState(searchParams.get(AlertFolderViewParams.nameFilter) ?? '');\n  const [labelFilter, setLabelFilter] = useState(searchParams.get(AlertFolderViewParams.labelFilter) ?? '');\n\n  const sortParam = searchParams.get(AlertFolderViewParams.sortOrder);\n  const [sortOrder, setSortOrder] = useState<SortOrder | undefined>(\n    sortParam === SortOrder.Ascending\n      ? SortOrder.Ascending\n      : sortParam === SortOrder.Descending\n      ? SortOrder.Descending\n      : undefined\n  );\n\n  useDebounce(\n    () =>\n      setSearchParams(\n        {\n          [AlertFolderViewParams.nameFilter]: getQueryParamValue(nameFilter),\n          [AlertFolderViewParams.labelFilter]: getQueryParamValue(labelFilter),\n          [AlertFolderViewParams.sortOrder]: getQueryParamValue(sortOrder),\n        },\n        true\n      ),\n    400,\n    [nameFilter, labelFilter, sortOrder]\n  );\n\n  return { nameFilter, labelFilter, sortOrder, setNameFilter, setLabelFilter, setSortOrder };\n}\n\nfunction filterAndSortRules(\n  originalRules: CombinedRule[],\n  nameFilter: string,\n  labelFilter: string,\n  sortOrder: SortOrder\n) {\n  const matchers = parseMatchers(labelFilter);\n  let rules = originalRules.filter(\n    (rule) => rule.name.toLowerCase().includes(nameFilter.toLowerCase()) && labelsMatchMatchers(rule.labels, matchers)\n  );\n\n  return orderBy(rules, (x) => x.name.toLowerCase(), [sortOrder === SortOrder.Ascending ? 'asc' : 'desc']);\n}\n\nexport const getStyles = (theme: GrafanaTheme2) => ({\n  container: css`\n    padding: ${theme.spacing(1)};\n  `,\n  card: css`\n    grid-template-columns: auto 1fr 2fr;\n    margin: 0;\n  `,\n  pagination: css`\n    align-self: center;\n  `,\n  filterLabelsInput: css`\n    flex: 1;\n    width: auto;\n    min-width: 240px;\n  `,\n  noResults: css`\n    padding: ${theme.spacing(2)};\n    background-color: ${theme.colors.background.secondary};\n    font-style: italic;\n  `,\n});\n","import React from 'react';\nimport { useAsync } from 'react-use';\n\nimport { Page } from 'app/core/components/Page/Page';\nimport { GrafanaRouteComponentProps } from 'app/core/navigation/types';\nimport { getNavModel } from 'app/core/selectors/navModel';\nimport { useDispatch, useSelector } from 'app/types';\n\nimport { AlertsFolderView } from '../alerting/unified/AlertsFolderView';\n\nimport { getFolderByUid } from './state/actions';\nimport { getLoadingNav } from './state/navModel';\n\nexport interface OwnProps extends GrafanaRouteComponentProps<{ uid: string }> {}\n\nconst FolderAlerting = ({ match }: OwnProps) => {\n  const dispatch = useDispatch();\n  const navIndex = useSelector((state) => state.navIndex);\n  const folder = useSelector((state) => state.folder);\n\n  const uid = match.params.uid;\n  const pageNav = getNavModel(navIndex, `folder-alerting-${uid}`, getLoadingNav(1));\n\n  const { loading } = useAsync(async () => dispatch(getFolderByUid(uid)), [getFolderByUid, uid]);\n\n  return (\n    <Page navId=\"dashboards/browse\" pageNav={pageNav.main}>\n      <Page.Contents isLoading={loading}>\n        <AlertsFolderView folder={folder} />\n      </Page.Contents>\n    </Page>\n  );\n};\n\nexport default FolderAlerting;\n"],"names":["useCombinedRuleNamespaces","rulesSourceName","promRulesResponses","useUnifiedAlertingSelector","state","promRules","rulerRulesResponses","rulerRules","cache","useRef","rulesSources","useMemo","rulesSource","getRulesSourceByName","Error","getAllRulesSources","map","isCloudRulesSource","name","result","cached","current","namespaces","Object","entries","forEach","namespaceName","groups","namespace","group","combinedGroup","interval","source_tenants","rules","rule","rulerRuleToCombinedRule","addRulerGroupsToCombinedNamespace","existingGroupsByName","Map","set","get","push","combinedRulesByName","r","existingRule","existingCombinedRulesMap","nameMatchingRules","isGrafanaRulesSource","strictlyMatchingRule","find","combinedRule","promRule","isCombinedRuleEqualToPromRule","looselyMatchingRule","getExistingRuleInGroup","query","labels","annotations","isAlertingRule","promRuleToCombinedRule","addPromGroupsToCombinedNamespace","values","flat","flattenGrafanaManagedRules","newNamespace","flatMap","sort","a","b","localeCompare","isAlertingRulerRule","alert","expr","rulerRule","isRecordingRulerRule","record","grafana_alert","title","checkQuery","isEqual","hashQuery","length","slice","replace","split","join","useURLSearchParams","search","useLocation","URLSearchParams","useCallback","searchValues","locationService","SortOrder","sortOptions","label","value","Ascending","Descending","AlertsFolderView","folder","styles","useStyles2","getStyles","dispatch","useDispatch","onTagClick","tagName","matchers","parseMatchers","labelFilter","tagMatcherField","parseMatcher","uniqueMatchers","uniqWith","matchersString","matchersToString","setLabelFilter","useEffect","fetchPromRulesAction","GRAFANA_RULES_SOURCE_NAME","fetchRulerRulesAction","combinedNamespaces","nameFilter","sortOrder","setNameFilter","setSortOrder","searchParams","setSearchParams","useState","AlertFolderViewParams","sortParam","undefined","useDebounce","getQueryParamValue","useAlertsFolderViewParams","matchingNamespace","alertRules","filteredRules","originalRules","filter","toLowerCase","includes","labelsMatchMatchers","orderBy","x","filterAndSortRules","hasNoResults","page","numberOfPages","onPageChange","pageItems","usePagination","DEFAULT_PER_PAGE_PAGINATION","className","container","Stack","direction","gap","FilterInput","onChange","placeholder","Select","options","width","prefix","Icon","filterLabelsInput","currentRule","Card","href","createViewLink","card","TagList","onClick","tags","noResults","pagination","Pagination","currentPage","onNavigate","hideWhenSinglePage","theme","css","spacing","colors","background","secondary","match","navIndex","useSelector","uid","params","pageNav","getNavModel","getLoadingNav","loading","useAsync","async","getFolderByUid","Page","navId","main","isLoading"],"sourceRoot":""}