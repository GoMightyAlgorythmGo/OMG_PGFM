{"version":3,"file":"266.8b15c3a14edd091baf9d.js","mappings":"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","sources":["webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/field/fieldComparers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/fieldTypeMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/refIdMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/simpleFieldMatcher.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/equalMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/nullMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/numericMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/rangeMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/matchers/valueMatchers/regexMatchers.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/transformations/transformers/ids.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/utils/Registry.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/ArrayVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/SortedVector.ts","webpack://grafana/./.yarn/__virtual__/@grafana-data-virtual-adf1e43f85/1/packages/grafana-data/src/vector/vectorToArray.ts","webpack://grafana/./.yarn/__virtual__/@grafana-runtime-virtual-f9d61a496b/1/packages/grafana-runtime/src/utils/toDataQueryError.ts","webpack://grafana/./public/app/features/live/centrifuge/LiveDataStream.ts","webpack://grafana/./public/app/features/live/centrifuge/channel.ts","webpack://grafana/./public/app/features/live/centrifuge/service.ts","webpack://grafana/./public/app/features/live/centrifuge/transferHandlers.ts","webpack://grafana/./public/app/plugins/datasource/prometheus/legend.ts"],"sourcesContent":["import { isNumber } from 'lodash';\n\nimport { dateTime } from '../datetime';\nimport { Field, FieldType } from '../types/dataFrame';\nimport { Vector } from '../types/vector';\n\ntype IndexComparer = (a: number, b: number) => number;\n\n/** @public */\nexport const fieldIndexComparer = (field: Field, reverse = false): IndexComparer => {\n  const values = field.values;\n\n  switch (field.type) {\n    case FieldType.number:\n      return numericIndexComparer(values, reverse);\n    case FieldType.string:\n      return stringIndexComparer(values, reverse);\n    case FieldType.boolean:\n      return booleanIndexComparer(values, reverse);\n    case FieldType.time:\n      return timeIndexComparer(values, reverse);\n    default:\n      return naturalIndexComparer(reverse);\n  }\n};\n\n/** @public */\nexport const timeComparer = (a: any, b: any): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n\n  if (isNumber(a) && isNumber(b)) {\n    return numericComparer(a, b);\n  }\n\n  if (dateTime(a).isBefore(b)) {\n    return -1;\n  }\n\n  if (dateTime(b).isBefore(a)) {\n    return 1;\n  }\n\n  return 0;\n};\n\n/** @public */\nexport const numericComparer = (a: number, b: number): number => {\n  return a - b;\n};\n\n/** @public */\nexport const stringComparer = (a: string, b: string): number => {\n  if (!a || !b) {\n    return falsyComparer(a, b);\n  }\n  return a.localeCompare(b);\n};\n\nexport const booleanComparer = (a: boolean, b: boolean): number => {\n  return falsyComparer(a, b);\n};\n\nconst falsyComparer = (a: any, b: any): number => {\n  if (!a && b) {\n    return 1;\n  }\n\n  if (a && !b) {\n    return -1;\n  }\n\n  return 0;\n};\n\nconst timeIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA = values.get(a);\n    const vB = values.get(b);\n    return reverse ? timeComparer(vB, vA) : timeComparer(vA, vB);\n  };\n};\n\nconst booleanIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA: boolean = values.get(a);\n    const vB: boolean = values.get(b);\n    return reverse ? booleanComparer(vB, vA) : booleanComparer(vA, vB);\n  };\n};\n\nconst numericIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA: number = values.get(a);\n    const vB: number = values.get(b);\n    return reverse ? numericComparer(vB, vA) : numericComparer(vA, vB);\n  };\n};\n\nconst stringIndexComparer = (values: Vector<any>, reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    const vA: string = values.get(a);\n    const vB: string = values.get(b);\n    return reverse ? stringComparer(vB, vA) : stringComparer(vA, vB);\n  };\n};\n\nconst naturalIndexComparer = (reverse: boolean): IndexComparer => {\n  return (a: number, b: number): number => {\n    return reverse ? numericComparer(b, a) : numericComparer(a, b);\n  };\n};\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\n// General Field matcher\nconst fieldTypeMatcher: FieldMatcherInfo<FieldType> = {\n  id: FieldMatcherID.byType,\n  name: 'Field Type',\n  description: 'match based on the field type',\n  defaultOptions: FieldType.number,\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return type === field.type;\n    };\n  },\n\n  getOptionsDisplayText: (type: FieldType) => {\n    return `Field type: ${type}`;\n  },\n};\n\n// Numeric Field matcher\n// This gets its own entry so it shows up in the dropdown\nconst numericMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.numeric,\n  name: 'Numeric Fields',\n  description: 'Fields with type number',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.number);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Numeric Fields';\n  },\n};\n\n// Time Field matcher\nconst timeMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.time,\n  name: 'Time Fields',\n  description: 'Fields with type time',\n\n  get: () => {\n    return fieldTypeMatcher.get(FieldType.time);\n  },\n\n  getOptionsDisplayText: () => {\n    return 'Time Fields';\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getFieldTypeMatchers(): FieldMatcherInfo[] {\n  return [fieldTypeMatcher, numericMatcher, timeMatcher];\n}\n","// This needs to be in its own file to avoid circular references\n\n// Builtin Predicates\n// not using 'any' and 'never' since they are reserved keywords\nexport enum MatcherID {\n  anyMatch = 'anyMatch', // checks children\n  allMatch = 'allMatch', // checks children\n  invertMatch = 'invertMatch', // checks child\n  alwaysMatch = 'alwaysMatch',\n  neverMatch = 'neverMatch',\n}\n\nexport enum FieldMatcherID {\n  // Specific Types\n  numeric = 'numeric',\n  time = 'time', // Can be multiple times\n  first = 'first',\n  firstTimeField = 'firstTimeField', // Only the first fime field\n\n  // With arguments\n  byType = 'byType',\n  byName = 'byName',\n  byNames = 'byNames',\n  byRegexp = 'byRegexp',\n  byRegexpOrNames = 'byRegexpOrNames',\n  byFrameRefID = 'byFrameRefID',\n  // byIndex = 'byIndex',\n  // byLabel = 'byLabel',\n}\n\n/**\n * Field name matchers\n */\nexport enum FrameMatcherID {\n  byName = 'byName',\n  byRefId = 'byRefId',\n  byIndex = 'byIndex',\n  byLabel = 'byLabel',\n}\n\n/**\n * @public\n */\nexport enum ValueMatcherID {\n  regex = 'regex',\n  isNull = 'isNull',\n  isNotNull = 'isNotNull',\n  greater = 'greater',\n  greaterOrEqual = 'greaterOrEqual',\n  lower = 'lower',\n  lowerOrEqual = 'lowerOrEqual',\n  equal = 'equal',\n  notEqual = 'notEqual',\n  between = 'between',\n}\n","import { stringToJsRegex } from '../../text';\nimport { DataFrame } from '../../types/dataFrame';\nimport { FrameMatcherInfo } from '../../types/transformations';\n\nimport { FrameMatcherID } from './ids';\n\n// General Field matcher\nconst refIdMacher: FrameMatcherInfo<string> = {\n  id: FrameMatcherID.byRefId,\n  name: 'Query refId',\n  description: 'match the refId',\n  defaultOptions: 'A',\n\n  get: (pattern: string) => {\n    const regex = stringToJsRegex(pattern);\n    return (frame: DataFrame) => {\n      return regex.test(frame.refId || '');\n    };\n  },\n\n  getOptionsDisplayText: (pattern: string) => {\n    return `RefID: ${pattern}`;\n  },\n};\n\nexport function getRefIdMatchers(): FrameMatcherInfo[] {\n  return [refIdMacher];\n}\n","import { Field, FieldType, DataFrame } from '../../types/dataFrame';\nimport { FieldMatcherInfo } from '../../types/transformations';\n\nimport { FieldMatcherID } from './ids';\n\nconst firstFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.first,\n  name: 'First Field',\n  description: 'The first field in the frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field === frame.fields[0];\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First field`;\n  },\n};\n\nconst firstTimeFieldMatcher: FieldMatcherInfo = {\n  id: FieldMatcherID.firstTimeField,\n  name: 'First time field',\n  description: 'The first field of type time in a frame',\n\n  get: (type: FieldType) => {\n    return (field: Field, frame: DataFrame, allFrames: DataFrame[]) => {\n      return field.type === FieldType.time && field === frame.fields.find((f) => f.type === FieldType.time);\n    };\n  },\n\n  getOptionsDisplayText: () => {\n    return `First time field`;\n  },\n};\n\n/**\n * Registry Initialization\n */\nexport function getSimpleFieldMatchers(): FieldMatcherInfo[] {\n  return [firstFieldMatcher, firstTimeFieldMatcher];\n}\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.equal,\n  name: 'Is equal',\n  description: 'Match where value for given field is equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value == options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nconst isNotEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions> = {\n  id: ValueMatcherID.notEqual,\n  name: 'Is not equal',\n  description: 'Match where value for given field is not equal to options value.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      // eslint-disable-next-line eqeqeq\n      return value != options.value;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '' }),\n};\n\nexport const getEqualValueMatchers = (): ValueMatcherInfo[] => [isEqualValueMatcher, isNotEqualValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { ValueMatcherOptions } from './types';\n\nconst isNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNull,\n  name: 'Is null',\n  description: 'Match where value for given field is null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value == null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nconst isNotNullValueMatcher: ValueMatcherInfo<ValueMatcherOptions> = {\n  id: ValueMatcherID.isNotNull,\n  name: 'Is not null',\n  description: 'Match where value for given field is not null.',\n  get: () => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return value != null;\n    };\n  },\n  getOptionsDisplayText: () => {\n    return `Matches all rows where field is not null.`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({}),\n};\n\nexport const getNullValueMatchers = (): ValueMatcherInfo[] => [isNullValueMatcher, isNotNullValueMatcher];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst isGreaterValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greater,\n  name: 'Is greater',\n  description: 'Match when field value is greater than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isGreaterOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.greaterOrEqual,\n  name: 'Is greater or equal',\n  description: 'Match when field value is greater than or equal to option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value >= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is greater than or equal to: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lower,\n  name: 'Is lower',\n  description: 'Match when field value is lower than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value < options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nconst isLowerOrEqualValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<number>> = {\n  id: ValueMatcherID.lowerOrEqual,\n  name: 'Is lower or equal',\n  description: 'Match when field value is lower or equal than option.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value <= options.value;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is lower or equal than: ${options.value}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ value: 0 }),\n};\n\nexport const getNumericValueMatchers = (): ValueMatcherInfo[] => [\n  isGreaterValueMatcher,\n  isGreaterOrEqualValueMatcher,\n  isLowerValueMatcher,\n  isLowerOrEqualValueMatcher,\n];\n","import { Field, FieldType } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { RangeValueMatcherOptions } from './types';\n\nconst isBetweenValueMatcher: ValueMatcherInfo<RangeValueMatcherOptions<number>> = {\n  id: ValueMatcherID.between,\n  name: 'Is between',\n  description: 'Match when field value is between given option values.',\n  get: (options) => {\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      if (isNaN(value)) {\n        return false;\n      }\n      return value > options.from && value < options.to;\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is between ${options.from} and ${options.to}.`;\n  },\n  isApplicable: (field) => field.type === FieldType.number,\n  getDefaultOptions: () => ({ from: 0, to: 100 }),\n};\n\nexport const getRangeValueMatchers = (): ValueMatcherInfo[] => [isBetweenValueMatcher];\n","import { Field } from '../../../types/dataFrame';\nimport { ValueMatcherInfo } from '../../../types/transformations';\nimport { ValueMatcherID } from '../ids';\n\nimport { BasicValueMatcherOptions } from './types';\n\nconst regexValueMatcher: ValueMatcherInfo<BasicValueMatcherOptions<string>> = {\n  id: ValueMatcherID.regex,\n  name: 'Regex',\n  description: 'Match when field value is matching regex.',\n  get: (options) => {\n    const regex = new RegExp(options.value);\n\n    return (valueIndex: number, field: Field) => {\n      const value = field.values.get(valueIndex);\n      return regex.test(value);\n    };\n  },\n  getOptionsDisplayText: (options) => {\n    return `Matches all rows where field value is matching regex: ${options.value}`;\n  },\n  isApplicable: () => true,\n  getDefaultOptions: () => ({ value: '.*' }),\n};\n\nexport const getRegexValueMatcher = (): ValueMatcherInfo[] => [regexValueMatcher];\n","export enum DataTransformerID {\n  append = 'append',\n  //  rotate = 'rotate', // Columns to rows\n  reduce = 'reduce',\n  order = 'order',\n  organize = 'organize',\n  rename = 'rename',\n  calculateField = 'calculateField',\n  /** @deprecated use joinByField */\n  seriesToColumns = 'seriesToColumns',\n  seriesToRows = 'seriesToRows',\n  merge = 'merge',\n  concatenate = 'concatenate',\n  labelsToFields = 'labelsToFields',\n  filterFields = 'filterFields',\n  filterFieldsByName = 'filterFieldsByName',\n  filterFrames = 'filterFrames',\n  filterByRefId = 'filterByRefId',\n  renameByRegex = 'renameByRegex',\n  filterByValue = 'filterByValue',\n  noop = 'noop',\n  ensureColumns = 'ensureColumns',\n  groupBy = 'groupBy',\n  sortBy = 'sortBy',\n  histogram = 'histogram',\n  configFromData = 'configFromData',\n  rowsToFields = 'rowsToFields',\n  prepareTimeSeries = 'prepareTimeSeries',\n  convertFieldType = 'convertFieldType',\n  fieldLookup = 'fieldLookup',\n  heatmap = 'heatmap',\n  spatial = 'spatial',\n  joinByField = 'joinByField',\n  joinByLabels = 'joinByLabels',\n  extractFields = 'extractFields',\n  groupingToMatrix = 'groupingToMatrix',\n  limit = 'limit',\n}\n","import { PluginState } from '../types';\nimport { SelectableValue } from '../types/select';\n\nexport interface RegistryItem {\n  id: string; // Unique Key -- saved in configs\n  name: string; // Display Name, can change without breaking configs\n  description?: string;\n  aliasIds?: string[]; // when the ID changes, we may want backwards compatibility ('current' => 'last')\n\n  /**\n   * Some extensions should not be user selectable\n   *  like: 'all' and 'any' matchers;\n   */\n  excludeFromPicker?: boolean;\n\n  /**\n   * Optional feature state\n   */\n  state?: PluginState;\n}\n\nexport interface RegistryItemWithOptions<TOptions = any> extends RegistryItem {\n  /**\n   * Convert the options to a string\n   */\n  getOptionsDisplayText?: (options: TOptions) => string;\n\n  /**\n   * Default options used if nothing else is specified\n   */\n  defaultOptions?: TOptions;\n}\n\ninterface RegistrySelectInfo {\n  options: Array<SelectableValue<string>>;\n  current: Array<SelectableValue<string>>;\n}\n\nexport class Registry<T extends RegistryItem> {\n  private ordered: T[] = [];\n  private byId = new Map<string, T>();\n  private initialized = false;\n\n  constructor(private init?: () => T[]) {}\n\n  setInit = (init: () => T[]) => {\n    if (this.initialized) {\n      throw new Error('Registry already initialized');\n    }\n    this.init = init;\n  };\n\n  getIfExists(id: string | undefined): T | undefined {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (id) {\n      return this.byId.get(id);\n    }\n\n    return undefined;\n  }\n\n  private initialize() {\n    if (this.init) {\n      for (const ext of this.init()) {\n        this.register(ext);\n      }\n    }\n    this.sort();\n    this.initialized = true;\n  }\n\n  get(id: string): T {\n    const v = this.getIfExists(id);\n    if (!v) {\n      throw new Error(`\"${id}\" not found in: ${this.list().map((v) => v.id)}`);\n    }\n    return v;\n  }\n\n  selectOptions(current?: string[], filter?: (ext: T) => boolean): RegistrySelectInfo {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    const select = {\n      options: [],\n      current: [],\n    } as RegistrySelectInfo;\n\n    const currentOptions: Record<string, SelectableValue<string>> = {};\n    if (current) {\n      for (const id of current) {\n        currentOptions[id] = {};\n      }\n    }\n\n    for (const ext of this.ordered) {\n      if (ext.excludeFromPicker) {\n        continue;\n      }\n      if (filter && !filter(ext)) {\n        continue;\n      }\n\n      const option = {\n        value: ext.id,\n        label: ext.name,\n        description: ext.description,\n      };\n\n      if (ext.state === PluginState.alpha) {\n        option.label += ' (alpha)';\n      }\n\n      select.options.push(option);\n      if (currentOptions[ext.id]) {\n        currentOptions[ext.id] = option;\n      }\n    }\n\n    if (current) {\n      // this makes sure we preserve the order of ids\n      select.current = Object.values(currentOptions);\n    }\n\n    return select;\n  }\n\n  /**\n   * Return a list of values by ID, or all values if not specified\n   */\n  list(ids?: string[]): T[] {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    if (ids) {\n      const found: T[] = [];\n      for (const id of ids) {\n        const v = this.getIfExists(id);\n        if (v) {\n          found.push(v);\n        }\n      }\n      return found;\n    }\n\n    return this.ordered;\n  }\n\n  isEmpty(): boolean {\n    if (!this.initialized) {\n      this.initialize();\n    }\n\n    return this.ordered.length === 0;\n  }\n\n  register(ext: T) {\n    if (this.byId.has(ext.id)) {\n      throw new Error('Duplicate Key:' + ext.id);\n    }\n\n    this.byId.set(ext.id, ext);\n    this.ordered.push(ext);\n\n    if (ext.aliasIds) {\n      for (const alias of ext.aliasIds) {\n        if (!this.byId.has(alias)) {\n          this.byId.set(alias, ext);\n        }\n      }\n    }\n\n    if (this.initialized) {\n      this.sort();\n    }\n  }\n\n  private sort() {\n    // TODO sort the list\n  }\n}\n","import { MutableVector } from '../types/vector';\n\nimport { FunctionalVector } from './FunctionalVector';\n\n/**\n * @public\n */\nexport class ArrayVector<T = any> extends FunctionalVector<T> implements MutableVector<T> {\n  buffer: T[];\n\n  constructor(buffer?: T[]) {\n    super();\n    this.buffer = buffer ? buffer : [];\n  }\n\n  get length() {\n    return this.buffer.length;\n  }\n\n  add(value: T) {\n    this.buffer.push(value);\n  }\n\n  get(index: number): T {\n    return this.buffer[index];\n  }\n\n  set(index: number, value: T) {\n    this.buffer[index] = value;\n  }\n\n  reverse() {\n    this.buffer.reverse();\n  }\n\n  toArray(): T[] {\n    return this.buffer;\n  }\n\n  toJSON(): T[] {\n    return this.buffer;\n  }\n}\n","import { Vector } from '../types/vector';\n\nimport { vectorToArray } from './vectorToArray';\n\n/**\n * Values are returned in the order defined by the input parameter\n */\nexport class SortedVector<T = any> implements Vector<T> {\n  constructor(private source: Vector<T>, private order: number[]) {}\n\n  get length(): number {\n    return this.source.length;\n  }\n\n  get(index: number): T {\n    return this.source.get(this.order[index]);\n  }\n\n  toArray(): T[] {\n    return vectorToArray(this);\n  }\n\n  toJSON(): T[] {\n    return vectorToArray(this);\n  }\n}\n","import { Vector } from '../types/vector';\n\nexport function vectorToArray<T>(v: Vector<T>): T[] {\n  const arr: T[] = Array(v.length);\n  for (let i = 0; i < v.length; i++) {\n    arr[i] = v.get(i);\n  }\n  return arr;\n}\n","import { DataQueryError } from '@grafana/data';\n\n/**\n * Convert an object into a DataQueryError -- if this is an HTTP response,\n * it will put the correct values in the error field\n *\n * @public\n */\nexport function toDataQueryError(err: DataQueryError | string | Object): DataQueryError {\n  const error = (err || {}) as DataQueryError;\n\n  if (!error.message) {\n    if (typeof err === 'string' || err instanceof String) {\n      return { message: err } as DataQueryError;\n    }\n\n    let message = 'Query error';\n    if (error.message) {\n      message = error.message;\n    } else if (error.data && error.data.message && error.data?.message !== 'Query data error') {\n      message = error.data.message;\n    } else if (error?.data?.message === 'Query data error' && error?.data?.error) {\n      message = error.data.error;\n    } else if (error.data && error.data.error) {\n      message = error.data.error;\n    } else if (error.status) {\n      message = `Query error: ${error.status} ${error.statusText}`;\n    }\n    error.message = message;\n  }\n\n  return error;\n}\n","import { map, Observable, ReplaySubject, Subject, Subscriber, Subscription } from 'rxjs';\n\nimport {\n  DataFrameJSON,\n  DataQueryError,\n  Field,\n  isLiveChannelMessageEvent,\n  isLiveChannelStatusEvent,\n  LiveChannelConnectionState,\n  LiveChannelEvent,\n  LiveChannelId,\n  LoadingState,\n} from '@grafana/data';\nimport { LiveDataStreamOptions, StreamingFrameAction, StreamingFrameOptions } from '@grafana/runtime/src/services/live';\nimport { toDataQueryError } from '@grafana/runtime/src/utils/toDataQueryError';\n\nimport { getStreamingFrameOptions, StreamingDataFrame } from '../data/StreamingDataFrame';\nimport { StreamingResponseDataType } from '../data/utils';\n\nimport { DataStreamSubscriptionKey, StreamingDataQueryResponse } from './service';\n\nconst bufferIfNot =\n  (canEmitObservable: Observable<boolean>) =>\n  <T>(source: Observable<T>): Observable<T[]> => {\n    return new Observable((subscriber: Subscriber<T[]>) => {\n      let buffer: T[] = [];\n      let canEmit = true;\n\n      const emitBuffer = () => {\n        subscriber.next(buffer);\n        buffer = [];\n      };\n\n      const canEmitSub = canEmitObservable.subscribe({\n        next: (val) => {\n          canEmit = val;\n\n          if (canEmit && buffer.length) {\n            emitBuffer();\n          }\n        },\n      });\n\n      const sourceSub = source.subscribe({\n        next(value) {\n          if (canEmit) {\n            if (!buffer.length) {\n              subscriber.next([value]);\n            } else {\n              emitBuffer();\n            }\n          } else {\n            buffer.push(value);\n          }\n        },\n        error(error) {\n          subscriber.error(error);\n        },\n        complete() {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        sourceSub.unsubscribe();\n        canEmitSub.unsubscribe();\n      };\n    });\n  };\n\nexport type DataStreamHandlerDeps<T> = {\n  channelId: LiveChannelId;\n  liveEventsObservable: Observable<LiveChannelEvent<T>>;\n  onShutdown: () => void;\n  subscriberReadiness: Observable<boolean>;\n  defaultStreamingFrameOptions: Readonly<StreamingFrameOptions>;\n  shutdownDelayInMs: number;\n};\n\nenum InternalStreamMessageType {\n  Error,\n  NewValuesSameSchema,\n  ChangedSchema,\n}\n\ntype InternalStreamMessageTypeToData = {\n  [InternalStreamMessageType.Error]: {\n    error: DataQueryError;\n  };\n  [InternalStreamMessageType.ChangedSchema]: {};\n  [InternalStreamMessageType.NewValuesSameSchema]: {\n    values: unknown[][];\n  };\n};\n\ntype InternalStreamMessage<T = InternalStreamMessageType> = T extends InternalStreamMessageType\n  ? {\n      type: T;\n    } & InternalStreamMessageTypeToData[T]\n  : never;\n\nconst reduceNewValuesSameSchemaMessages = (\n  packets: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n) => ({\n  values: packets.reduce((acc, { values }) => {\n    for (let i = 0; i < values.length; i++) {\n      if (!acc[i]) {\n        acc[i] = [];\n      }\n      for (let j = 0; j < values[i].length; j++) {\n        acc[i].push(values[i][j]);\n      }\n    }\n    return acc;\n  }, [] as unknown[][]),\n  type: InternalStreamMessageType.NewValuesSameSchema,\n});\n\nconst filterMessages = <T extends InternalStreamMessageType>(\n  packets: InternalStreamMessage[],\n  type: T\n): Array<InternalStreamMessage<T>> => packets.filter((p) => p.type === type) as Array<InternalStreamMessage<T>>;\n\nexport class LiveDataStream<T = unknown> {\n  private frameBuffer: StreamingDataFrame;\n  private liveEventsSubscription: Subscription;\n  private stream: Subject<InternalStreamMessage> = new ReplaySubject(1);\n  private shutdownTimeoutId: ReturnType<typeof setTimeout> | undefined;\n\n  constructor(private deps: DataStreamHandlerDeps<T>) {\n    this.frameBuffer = StreamingDataFrame.empty(deps.defaultStreamingFrameOptions);\n    this.liveEventsSubscription = deps.liveEventsObservable.subscribe({\n      error: this.onError,\n      complete: this.onComplete,\n      next: this.onNext,\n    });\n  }\n\n  private shutdown = () => {\n    this.stream.complete();\n    this.liveEventsSubscription.unsubscribe();\n    this.deps.onShutdown();\n  };\n\n  private shutdownIfNoSubscribers = () => {\n    if (!this.stream.observed) {\n      this.shutdown();\n    }\n  };\n\n  private onError = (err: any) => {\n    console.log('LiveQuery [error]', { err }, this.deps.channelId);\n    this.stream.next({\n      type: InternalStreamMessageType.Error,\n      error: toDataQueryError(err),\n    });\n    this.shutdown();\n  };\n\n  private onComplete = () => {\n    console.log('LiveQuery [complete]', this.deps.channelId);\n    this.shutdown();\n  };\n\n  private onNext = (evt: LiveChannelEvent) => {\n    if (isLiveChannelMessageEvent(evt)) {\n      this.process(evt.message);\n      return;\n    }\n\n    const liveChannelStatusEvent = isLiveChannelStatusEvent(evt);\n    if (liveChannelStatusEvent && evt.error) {\n      this.stream.next({\n        type: InternalStreamMessageType.Error,\n        error: {\n          ...toDataQueryError(evt.error),\n          message: `Streaming channel error: ${evt.error.message}`,\n        },\n      });\n      return;\n    }\n\n    if (\n      liveChannelStatusEvent &&\n      (evt.state === LiveChannelConnectionState.Connected || evt.state === LiveChannelConnectionState.Pending) &&\n      evt.message\n    ) {\n      this.process(evt.message);\n    }\n  };\n\n  private process = (msg: DataFrameJSON) => {\n    const packetInfo = this.frameBuffer.push(msg);\n\n    if (packetInfo.schemaChanged) {\n      this.stream.next({\n        type: InternalStreamMessageType.ChangedSchema,\n      });\n    } else {\n      this.stream.next({\n        type: InternalStreamMessageType.NewValuesSameSchema,\n        values: this.frameBuffer.getValuesFromLastPacket(),\n      });\n    }\n  };\n\n  private resizeBuffer = (bufferOptions: StreamingFrameOptions) => {\n    if (bufferOptions && this.frameBuffer.needsResizing(bufferOptions)) {\n      this.frameBuffer.resize(bufferOptions);\n    }\n  };\n\n  private prepareInternalStreamForNewSubscription = (options: LiveDataStreamOptions): void => {\n    if (!this.frameBuffer.hasAtLeastOnePacket() && options.frame) {\n      // will skip initial frames from subsequent subscribers\n      this.process(options.frame);\n    }\n  };\n\n  private clearShutdownTimeout = () => {\n    if (this.shutdownTimeoutId) {\n      clearTimeout(this.shutdownTimeoutId);\n      this.shutdownTimeoutId = undefined;\n    }\n  };\n\n  get = (options: LiveDataStreamOptions, subKey: DataStreamSubscriptionKey): Observable<StreamingDataQueryResponse> => {\n    this.clearShutdownTimeout();\n    const buffer = getStreamingFrameOptions(options.buffer);\n\n    this.resizeBuffer(buffer);\n    this.prepareInternalStreamForNewSubscription(options);\n\n    const shouldSendLastPacketOnly = options?.buffer?.action === StreamingFrameAction.Replace;\n    const fieldsNamesFilter = options.filter?.fields;\n    const dataNeedsFiltering = fieldsNamesFilter?.length;\n    const fieldFilterPredicate = dataNeedsFiltering ? ({ name }: Field) => fieldsNamesFilter.includes(name) : undefined;\n    let matchingFieldIndexes: number[] | undefined = undefined;\n\n    const getFullFrameResponseData = <T>(\n      messages: InternalStreamMessage[],\n      error?: DataQueryError\n    ): StreamingDataQueryResponse => {\n      matchingFieldIndexes = fieldFilterPredicate\n        ? this.frameBuffer.getMatchingFieldIndexes(fieldFilterPredicate)\n        : undefined;\n\n      if (!shouldSendLastPacketOnly) {\n        return {\n          key: subKey,\n          state: error ? LoadingState.Error : LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (error) {\n        // send empty frame with error\n        return {\n          key: subKey,\n          state: LoadingState.Error,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      if (!messages.length) {\n        console.warn(`expected to find at least one non error message ${messages.map(({ type }) => type)}`);\n        // send empty frame\n        return {\n          key: subKey,\n          state: LoadingState.Streaming,\n          data: [\n            {\n              type: StreamingResponseDataType.FullFrame,\n              frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, { maxLength: 0 }),\n            },\n          ],\n          error,\n        };\n      }\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.FullFrame,\n            frame: this.frameBuffer.serialize(fieldFilterPredicate, buffer, {\n              maxLength: this.frameBuffer.packetInfo.length,\n            }),\n          },\n        ],\n        error,\n      };\n    };\n\n    const getNewValuesSameSchemaResponseData = (\n      messages: Array<InternalStreamMessage<InternalStreamMessageType.NewValuesSameSchema>>\n    ): StreamingDataQueryResponse => {\n      const lastMessage = messages.length ? messages[messages.length - 1] : undefined;\n      const values =\n        shouldSendLastPacketOnly && lastMessage\n          ? lastMessage.values\n          : reduceNewValuesSameSchemaMessages(messages).values;\n\n      const filteredValues = matchingFieldIndexes\n        ? values.filter((v, i) => (matchingFieldIndexes as number[]).includes(i))\n        : values;\n\n      return {\n        key: subKey,\n        state: LoadingState.Streaming,\n        data: [\n          {\n            type: StreamingResponseDataType.NewValuesSameSchema,\n            values: filteredValues,\n          },\n        ],\n      };\n    };\n\n    let shouldSendFullFrame = true;\n    const transformedInternalStream = this.stream.pipe(\n      bufferIfNot(this.deps.subscriberReadiness),\n      map((messages, i) => {\n        const errors = filterMessages(messages, InternalStreamMessageType.Error);\n        const lastError = errors.length ? errors[errors.length - 1].error : undefined;\n\n        if (shouldSendFullFrame) {\n          shouldSendFullFrame = false;\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        if (errors.length) {\n          // send the latest frame with the last error, discard everything else\n          return getFullFrameResponseData(messages, lastError);\n        }\n\n        const schemaChanged = messages.some((n) => n.type === InternalStreamMessageType.ChangedSchema);\n        if (schemaChanged) {\n          // send the latest frame, discard intermediate appends\n          return getFullFrameResponseData(messages, undefined);\n        }\n\n        const newValueSameSchemaMessages = filterMessages(messages, InternalStreamMessageType.NewValuesSameSchema);\n        if (newValueSameSchemaMessages.length !== messages.length) {\n          console.warn(`unsupported message type ${messages.map(({ type }) => type)}`);\n        }\n\n        return getNewValuesSameSchemaResponseData(newValueSameSchemaMessages);\n      })\n    );\n\n    return new Observable<StreamingDataQueryResponse>((subscriber) => {\n      const sub = transformedInternalStream.subscribe({\n        next: (n) => {\n          subscriber.next(n);\n        },\n        error: (err) => {\n          subscriber.error(err);\n        },\n        complete: () => {\n          subscriber.complete();\n        },\n      });\n\n      return () => {\n        // TODO: potentially resize (downsize) the buffer on unsubscribe\n        sub.unsubscribe();\n        if (!this.stream.observed) {\n          this.clearShutdownTimeout();\n          this.shutdownTimeoutId = setTimeout(this.shutdownIfNoSubscribers, this.deps.shutdownDelayInMs);\n        }\n      };\n    });\n  };\n}\n","import {\n  Subscription,\n  JoinContext,\n  LeaveContext,\n  PublicationContext,\n  SubscriptionErrorContext,\n  SubscribedContext,\n} from 'centrifuge';\nimport { Subject, of, Observable } from 'rxjs';\n\nimport {\n  LiveChannelStatusEvent,\n  LiveChannelEvent,\n  LiveChannelEventType,\n  LiveChannelConnectionState,\n  LiveChannelPresenceStatus,\n  LiveChannelAddress,\n  DataFrameJSON,\n  isValidLiveChannelAddress,\n} from '@grafana/data';\n\n/**\n * Internal class that maps Centrifuge support to GrafanaLive\n */\nexport class CentrifugeLiveChannel<T = any> {\n  readonly currentStatus: LiveChannelStatusEvent;\n\n  readonly opened = Date.now();\n  readonly id: string;\n  readonly addr: LiveChannelAddress;\n\n  readonly stream = new Subject<LiveChannelEvent<T>>();\n\n  // Hold on to the last header with schema\n  lastMessageWithSchema?: DataFrameJSON;\n\n  subscription?: Subscription;\n  shutdownCallback?: () => void;\n  initalized?: boolean;\n\n  constructor(id: string, addr: LiveChannelAddress) {\n    this.id = id;\n    this.addr = addr;\n    this.currentStatus = {\n      type: LiveChannelEventType.Status,\n      id,\n      timestamp: this.opened,\n      state: LiveChannelConnectionState.Pending,\n    };\n    if (!isValidLiveChannelAddress(addr)) {\n      this.currentStatus.state = LiveChannelConnectionState.Invalid;\n      this.currentStatus.error = 'invalid channel address';\n    }\n  }\n\n  // This should only be called when centrifuge is connected\n  initalize(): void {\n    if (this.initalized) {\n      throw new Error('Channel already initalized: ' + this.id);\n    }\n    this.initalized = true;\n\n    this.subscription!.on('publication', (ctx: PublicationContext) => {\n      try {\n        if (ctx.data) {\n          if (ctx.data.schema) {\n            this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n          }\n\n          this.stream.next({\n            type: LiveChannelEventType.Message,\n            message: ctx.data,\n          });\n        }\n\n        // Clear any error messages\n        if (this.currentStatus.error) {\n          this.currentStatus.timestamp = Date.now();\n          delete this.currentStatus.error;\n          this.sendStatus();\n        }\n      } catch (err) {\n        console.log('publish error', this.addr, err);\n        this.currentStatus.error = err;\n        this.currentStatus.timestamp = Date.now();\n        this.sendStatus();\n      }\n    })\n      .on('error', (ctx: SubscriptionErrorContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.error = ctx.error.message;\n        this.sendStatus();\n      })\n      .on('subscribed', (ctx: SubscribedContext) => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connected;\n        delete this.currentStatus.error;\n\n        if (ctx.data?.schema) {\n          this.lastMessageWithSchema = ctx.data as DataFrameJSON;\n        }\n        this.sendStatus(ctx.data);\n      })\n      .on('unsubscribed', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Disconnected;\n        this.sendStatus();\n      })\n      .on('subscribing', () => {\n        this.currentStatus.timestamp = Date.now();\n        this.currentStatus.state = LiveChannelConnectionState.Connecting;\n        this.sendStatus();\n      })\n      .on('join', (ctx: JoinContext) => {\n        this.stream.next({ type: LiveChannelEventType.Join, user: ctx.info.user });\n      })\n      .on('leave', (ctx: LeaveContext) => {\n        this.stream.next({ type: LiveChannelEventType.Leave, user: ctx.info.user });\n      });\n  }\n\n  private sendStatus(message?: any) {\n    const copy = { ...this.currentStatus };\n    if (message) {\n      copy.message = message;\n    }\n    this.stream.next(copy);\n  }\n\n  disconnectIfNoListeners = () => {\n    const count = this.stream.observers.length;\n    if (count === 0) {\n      this.disconnect();\n    }\n  };\n\n  /**\n   * Get the stream of events and\n   */\n  getStream() {\n    return new Observable((subscriber) => {\n      const initialMessage = { ...this.currentStatus };\n      if (this.lastMessageWithSchema?.schema) {\n        // send just schema instead of schema+data to avoid having data gaps\n        initialMessage.message = { schema: this.lastMessageWithSchema?.schema };\n      }\n\n      subscriber.next({ ...this.currentStatus, message: this.lastMessageWithSchema });\n\n      const sub = this.stream.subscribe(subscriber);\n      return () => {\n        sub.unsubscribe();\n        const count = this.stream.observers.length;\n\n        // Wait 1/4 second to fully disconnect\n        if (count === 0) {\n          setTimeout(this.disconnectIfNoListeners, 250);\n        }\n      };\n    }) as Observable<LiveChannelEvent<T>>;\n  }\n\n  /**\n   * This is configured by the server when the config supports presence\n   */\n  async getPresence(): Promise<LiveChannelPresenceStatus> {\n    if (!this.subscription) {\n      return Promise.reject('not subscribed');\n    }\n\n    return this.subscription!.presence().then((v) => {\n      return {\n        users: Object.keys(v.clients),\n      };\n    });\n  }\n\n  /**\n   * This will close and terminate all streams for this channel\n   */\n  disconnect() {\n    this.currentStatus.state = LiveChannelConnectionState.Shutdown;\n    this.currentStatus.timestamp = Date.now();\n\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n      this.subscription.removeAllListeners(); // they keep all listeners attached after unsubscribe\n      this.subscription = undefined;\n    }\n\n    this.stream.complete();\n\n    this.stream.next({ ...this.currentStatus });\n    this.stream.complete();\n\n    if (this.shutdownCallback) {\n      this.shutdownCallback();\n    }\n  }\n\n  shutdownWithError(err: string) {\n    this.currentStatus.error = err;\n    this.sendStatus();\n    this.disconnect();\n  }\n}\n\nexport function getErrorChannel<TMessage>(msg: string, id: string, addr: LiveChannelAddress) {\n  return {\n    id,\n    opened: Date.now(),\n    addr,\n\n    // return an error\n    getStream: () =>\n      of({\n        type: LiveChannelEventType.Status,\n        id,\n        timestamp: Date.now(),\n        state: LiveChannelConnectionState.Invalid,\n        error: msg,\n      }),\n\n    // already disconnected\n    disconnect: () => {},\n  };\n}\n","import { Centrifuge, State } from 'centrifuge';\nimport { BehaviorSubject, Observable, share, startWith } from 'rxjs';\n\nimport {\n  DataQueryError,\n  DataQueryResponse,\n  LiveChannelAddress,\n  LiveChannelConnectionState,\n  LiveChannelId,\n  toLiveChannelId,\n} from '@grafana/data';\nimport { FetchResponse } from '@grafana/runtime/src/services/backendSrv';\nimport {\n  GrafanaLiveSrv,\n  LiveDataStreamOptions,\n  LiveQueryDataOptions,\n  StreamingFrameAction,\n  StreamingFrameOptions,\n} from '@grafana/runtime/src/services/live';\nimport { BackendDataSourceResponse } from '@grafana/runtime/src/utils/queryResponse';\n\nimport { StreamingResponseData } from '../data/utils';\n\nimport { LiveDataStream } from './LiveDataStream';\nimport { CentrifugeLiveChannel } from './channel';\n\nexport type CentrifugeSrvDeps = {\n  grafanaAuthToken: string | null;\n  appUrl: string;\n  orgId: number;\n  orgRole: string;\n  sessionId: string;\n  liveEnabled: boolean;\n  dataStreamSubscriberReadiness: Observable<boolean>;\n};\n\nexport type StreamingDataQueryResponse = Omit<DataQueryResponse, 'data'> & { data: [StreamingResponseData] };\n\nexport type CentrifugeSrv = Omit<GrafanaLiveSrv, 'publish' | 'getDataStream' | 'getQueryData'> & {\n  getDataStream: (options: LiveDataStreamOptions) => Observable<StreamingDataQueryResponse>;\n  getQueryData: (\n    options: LiveQueryDataOptions\n  ) => Promise<\n    | { data: BackendDataSourceResponse | undefined }\n    | FetchResponse<BackendDataSourceResponse | undefined>\n    | DataQueryError\n  >;\n};\n\nexport type DataStreamSubscriptionKey = string;\n\nconst defaultStreamingFrameOptions: Readonly<StreamingFrameOptions> = {\n  maxLength: 100,\n  maxDelta: Infinity,\n  action: StreamingFrameAction.Append,\n};\n\nconst dataStreamShutdownDelayInMs = 5000;\n\nexport class CentrifugeService implements CentrifugeSrv {\n  readonly open = new Map<string, CentrifugeLiveChannel>();\n  private readonly liveDataStreamByChannelId: Record<LiveChannelId, LiveDataStream> = {};\n  readonly centrifuge: Centrifuge;\n  readonly connectionState: BehaviorSubject<boolean>;\n  readonly connectionBlocker: Promise<void>;\n  private readonly dataStreamSubscriberReadiness: Observable<boolean>;\n\n  constructor(private deps: CentrifugeSrvDeps) {\n    this.dataStreamSubscriberReadiness = deps.dataStreamSubscriberReadiness.pipe(share(), startWith(true));\n\n    let liveUrl = `${deps.appUrl.replace(/^http/, 'ws')}/api/live/ws`;\n\n    const token = deps.grafanaAuthToken;\n    if (token !== null && token !== '') {\n      liveUrl += '?auth_token=' + token;\n    }\n\n    this.centrifuge = new Centrifuge(liveUrl, {\n      timeout: 30000,\n    });\n    // orgRole is set when logged in *or* anonymous users can use grafana\n    if (deps.liveEnabled && deps.orgRole !== '') {\n      this.centrifuge.connect(); // do connection\n    }\n    this.connectionState = new BehaviorSubject<boolean>(this.centrifuge.state === State.Connected);\n    this.connectionBlocker = new Promise<void>((resolve) => {\n      if (this.centrifuge.state === State.Connected) {\n        return resolve();\n      }\n      const connectListener = () => {\n        resolve();\n        this.centrifuge.removeListener('connected', connectListener);\n      };\n      this.centrifuge.addListener('connected', connectListener);\n    });\n\n    // Register global listeners\n    this.centrifuge.on('connected', this.onConnect);\n    this.centrifuge.on('connecting', this.onDisconnect);\n    this.centrifuge.on('disconnected', this.onDisconnect);\n    this.centrifuge.on('publication', this.onServerSideMessage);\n  }\n\n  //----------------------------------------------------------\n  // Internal functions\n  //----------------------------------------------------------\n\n  private onConnect = (context: any) => {\n    this.connectionState.next(true);\n  };\n\n  private onDisconnect = (context: any) => {\n    this.connectionState.next(false);\n  };\n\n  private onServerSideMessage = (context: any) => {\n    console.log('Publication from server-side channel', context);\n  };\n\n  /**\n   * Get a channel.  If the scope, namespace, or path is invalid, a shutdown\n   * channel will be returned with an error state indicated in its status\n   */\n  private getChannel<TMessage>(addr: LiveChannelAddress): CentrifugeLiveChannel<TMessage> {\n    const id = `${this.deps.orgId}/${addr.scope}/${addr.namespace}/${addr.path}`;\n    let channel = this.open.get(id);\n    if (channel != null) {\n      return channel;\n    }\n\n    channel = new CentrifugeLiveChannel(id, addr);\n    if (channel.currentStatus.state === LiveChannelConnectionState.Invalid) {\n      return channel;\n    }\n    channel.shutdownCallback = () => {\n      this.open.delete(id); // remove it from the list of open channels\n    };\n    this.open.set(id, channel);\n\n    // Initialize the channel in the background\n    this.initChannel(channel).catch((err) => {\n      if (channel) {\n        channel.currentStatus.state = LiveChannelConnectionState.Invalid;\n        channel.shutdownWithError(err);\n      }\n      this.open.delete(id);\n    });\n\n    // return the not-yet initialized channel\n    return channel;\n  }\n\n  private async initChannel(channel: CentrifugeLiveChannel): Promise<void> {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    const subscription = this.centrifuge.newSubscription(channel.id, {\n      data: channel.addr.data,\n    });\n    channel.subscription = subscription;\n    channel.initalize();\n    subscription.subscribe();\n    return;\n  }\n\n  //----------------------------------------------------------\n  // Exported functions\n  //----------------------------------------------------------\n\n  /**\n   * Listen for changes to the connection state\n   */\n  getConnectionState = () => {\n    return this.connectionState.asObservable();\n  };\n\n  /**\n   * Watch for messages in a channel\n   */\n  getStream: CentrifugeSrv['getStream'] = <T>(address: LiveChannelAddress) => {\n    return this.getChannel<T>(address).getStream();\n  };\n\n  private createSubscriptionKey = (options: LiveDataStreamOptions): DataStreamSubscriptionKey =>\n    options.key ?? `xstr/${streamCounter++}`;\n\n  private getLiveDataStream = (options: LiveDataStreamOptions): LiveDataStream => {\n    const channelId = toLiveChannelId(options.addr);\n    const existingStream = this.liveDataStreamByChannelId[channelId];\n\n    if (existingStream) {\n      return existingStream;\n    }\n\n    const channel = this.getChannel(options.addr);\n    this.liveDataStreamByChannelId[channelId] = new LiveDataStream({\n      channelId,\n      onShutdown: () => {\n        delete this.liveDataStreamByChannelId[channelId];\n      },\n      liveEventsObservable: channel.getStream(),\n      subscriberReadiness: this.dataStreamSubscriberReadiness,\n      defaultStreamingFrameOptions,\n      shutdownDelayInMs: dataStreamShutdownDelayInMs,\n    });\n    return this.liveDataStreamByChannelId[channelId];\n  };\n  /**\n   * Connect to a channel and return results as DataFrames\n   */\n  getDataStream: CentrifugeSrv['getDataStream'] = (options) => {\n    const subscriptionKey = this.createSubscriptionKey(options);\n\n    const stream = this.getLiveDataStream(options);\n    return stream.get(options, subscriptionKey);\n  };\n\n  /**\n   * Executes a query over the live websocket. Query response can contain live channels we can subscribe to for further updates\n   *\n   * Since the initial request and subscription are on the same socket, this will support HA setups\n   */\n  getQueryData: CentrifugeSrv['getQueryData'] = async (options) => {\n    if (this.centrifuge.state !== State.Connected) {\n      await this.connectionBlocker;\n    }\n    return this.centrifuge.rpc('grafana.query', options.body);\n  };\n\n  /**\n   * For channels that support presence, this will request the current state from the server.\n   *\n   * Join and leave messages will be sent to the open stream\n   */\n  getPresence: CentrifugeSrv['getPresence'] = (address) => {\n    return this.getChannel(address).getPresence();\n  };\n}\n\n// This is used to give a unique key for each stream.  The actual value does not matter\nlet streamCounter = 0;\n","import * as comlink from 'comlink';\nimport { Subscriber } from 'rxjs';\n\n// Observers, ie. functions passed to `observable.subscribe(...)`, are converted to a subclass of `Subscriber` before they are sent to the source Observable.\n// The conversion happens internally in the RxJS library - this transfer handler is catches them and wraps them with a proxy\nconst subscriberTransferHandler: any = {\n  canHandle(value: any): boolean {\n    return value && value instanceof Subscriber;\n  },\n\n  serialize(value: Function): [MessagePort, Transferable[]] {\n    const obj = comlink.proxy(value);\n\n    const { port1, port2 } = new MessageChannel();\n\n    comlink.expose(obj, port1);\n\n    return [port2, [port2]];\n  },\n\n  deserialize(value: MessagePort): comlink.Remote<MessagePort> {\n    value.start();\n\n    return comlink.wrap<MessagePort>(value);\n  },\n};\ncomlink.transferHandlers.set('SubscriberHandler', subscriberTransferHandler);\n","import { Labels } from '@grafana/data';\n\n/** replace labels in a string.  Used for loki+prometheus legend formats */\nexport function renderLegendFormat(aliasPattern: string, aliasData: Labels): string {\n  const aliasRegex = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n  return aliasPattern.replace(aliasRegex, (_, g1) => (aliasData[g1] ? aliasData[g1] : g1));\n}\n"],"names":["fieldIndexComparer","field","reverse","values","type","FieldType","numericIndexComparer","stringIndexComparer","booleanIndexComparer","timeIndexComparer","naturalIndexComparer","timeComparer","a","b","isNumber","numericComparer","dateTime","isBefore","falsyComparer","stringComparer","localeCompare","booleanComparer","vA","get","vB","fieldTypeMatcher","id","FieldMatcherID","name","description","defaultOptions","frame","allFrames","getOptionsDisplayText","numericMatcher","timeMatcher","getFieldTypeMatchers","MatcherID","FrameMatcherID","ValueMatcherID","refIdMacher","pattern","regex","stringToJsRegex","test","refId","getRefIdMatchers","firstFieldMatcher","fields","firstTimeFieldMatcher","find","f","getSimpleFieldMatchers","isEqualValueMatcher","options","valueIndex","value","isApplicable","getDefaultOptions","isNotEqualValueMatcher","getEqualValueMatchers","isNullValueMatcher","isNotNullValueMatcher","getNullValueMatchers","isGreaterValueMatcher","isNaN","isGreaterOrEqualValueMatcher","isLowerValueMatcher","isLowerOrEqualValueMatcher","getNumericValueMatchers","isBetweenValueMatcher","from","to","getRangeValueMatchers","regexValueMatcher","RegExp","getRegexValueMatcher","DataTransformerID","Registry","constructor","init","Map","this","initialized","Error","getIfExists","initialize","byId","ext","register","sort","v","list","map","selectOptions","current","filter","select","currentOptions","ordered","excludeFromPicker","option","label","state","PluginState","push","Object","ids","found","isEmpty","length","has","set","aliasIds","alias","ArrayVector","FunctionalVector","buffer","super","add","index","toArray","toJSON","SortedVector","source","order","vectorToArray","arr","Array","i","toDataQueryError","err","error","message","String","data","status","statusText","InternalStreamMessageType","filterMessages","packets","p","LiveDataStream","deps","ReplaySubject","stream","complete","liveEventsSubscription","unsubscribe","onShutdown","observed","shutdown","console","log","channelId","next","evt","isLiveChannelMessageEvent","process","liveChannelStatusEvent","isLiveChannelStatusEvent","LiveChannelConnectionState","msg","frameBuffer","schemaChanged","ChangedSchema","NewValuesSameSchema","getValuesFromLastPacket","bufferOptions","needsResizing","resize","hasAtLeastOnePacket","shutdownTimeoutId","clearTimeout","undefined","subKey","clearShutdownTimeout","getStreamingFrameOptions","resizeBuffer","prepareInternalStreamForNewSubscription","shouldSendLastPacketOnly","action","StreamingFrameAction","fieldsNamesFilter","fieldFilterPredicate","includes","matchingFieldIndexes","getFullFrameResponseData","messages","getMatchingFieldIndexes","key","LoadingState","StreamingResponseDataType","serialize","maxLength","packetInfo","warn","getNewValuesSameSchemaResponseData","lastMessage","reduce","acc","j","filteredValues","shouldSendFullFrame","transformedInternalStream","pipe","canEmitObservable","subscriberReadiness","Observable","subscriber","canEmit","emitBuffer","canEmitSub","subscribe","val","sourceSub","errors","lastError","some","n","newValueSameSchemaMessages","sub","setTimeout","shutdownIfNoSubscribers","shutdownDelayInMs","StreamingDataFrame","defaultStreamingFrameOptions","liveEventsObservable","onError","onComplete","onNext","CentrifugeLiveChannel","addr","Date","now","Subject","observers","disconnect","currentStatus","LiveChannelEventType","timestamp","opened","isValidLiveChannelAddress","initalize","initalized","subscription","on","ctx","schema","lastMessageWithSchema","sendStatus","user","info","copy","getStream","initialMessage","disconnectIfNoListeners","presence","then","users","keys","clients","Promise","reject","removeAllListeners","shutdownCallback","shutdownWithError","maxDelta","Infinity","CentrifugeService","context","connectionState","asObservable","address","getChannel","streamCounter","toLiveChannelId","existingStream","liveDataStreamByChannelId","channel","dataStreamSubscriberReadiness","subscriptionKey","createSubscriptionKey","getLiveDataStream","async","centrifuge","State","connectionBlocker","rpc","body","getPresence","share","startWith","liveUrl","appUrl","replace","token","grafanaAuthToken","Centrifuge","timeout","liveEnabled","orgRole","connect","BehaviorSubject","resolve","connectListener","removeListener","addListener","onConnect","onDisconnect","onServerSideMessage","orgId","scope","namespace","path","open","delete","initChannel","catch","newSubscription","subscriberTransferHandler","canHandle","Subscriber","obj","comlink","port1","port2","MessageChannel","deserialize","start","renderLegendFormat","aliasPattern","aliasData","_","g1"],"sourceRoot":""}